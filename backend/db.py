import asyncpg
import sqlparse
from shared.config import DATABASE_URL
from collections import defaultdict


def sql_safety(sql: str) -> bool:
    """
    This funtion checks if the SQL is safe.
    Only SELECT statement is allowed.

    Args:
        sql (str): SQL query to check generated by the llm

    Returns:
        bool: True if SQL is SELECT, False otherwise
    """
    try:
        parsed = sqlparse.parse(sql)
        if not parsed:
            return False
        statement = parsed[0].get_type() == "SELECT"
        return statement
    except Exception:
        return False


async def execute_sql_query(sql: str) -> list:
    """
    This function will execute a SQL query generated by the LLM and return the results.
    Args:
        sql (str): SQL auery to execute
    Returns:
        list: List of Dicts (Rows)
    """
    #  Checking Safety
    if not sql_safety(sql):
        raise ValueError("Only SELECT statements are allowed.")

    connection = await asyncpg.connect(DATABASE_URL)

    try:
        rows = await connection.fetch(sql)
        # COnverting each row to a dict
        return [dict(row) for row in rows]
    finally:
        await connection.close()


async def database_schema() -> dict:
    """
    This function retrieves the database schema, including table names, column names, and data types.
    Returns:
        schema (dict): A dict where keys are table names and values are a list of dicts with column name and dtypes.
        {key:[{}]}
    """
    connection = await asyncpg.connect(DATABASE_URL)

    schema = defaultdict(list)

    try:
        query = """
        SELECT table_name, column_name, data_type
        FROM information_schema.columns
        WHERE table_schema = 'public'
        ORDER BY table_name, column_name;
        """

        rows = await connection.fetch(query)
        for row in rows:
            table = row["table_name"]
            column = row["column_name"]
            dtype = row["data_type"]

            schema[table].append({"column": column, "data_type": dtype})
        return schema

    finally:
        await connection.close()
